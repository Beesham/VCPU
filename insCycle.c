/*
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
*/
#include "MyLib.h"
//#include "RegistersVar.h"
//#include "MyDefines.h"

//#define LR reg[14]
//#define SP reg[13]
//#define PC	pc

unsigned short irX; //holds the value of which register to use, ir0/ir1

unsigned short rd,rn;
unsigned long immeVal;
unsigned short LBit;
unsigned short HBBit;
unsigned short RBit;
unsigned long ALU;
unsigned short regListBits;
unsigned short regListArr[7] = {NULL};

/*
	splitIR
	Description: determines which instruction register to use IR1/IR2
*/
void splitIR(){
	printf("\n**Splitting irR**");

	ir0 = (irR >> 16) & irM;
	//printf("\nir0: %04X ",ir0);
	ir1 = irR & irM;
	//printf("\tir1: %04X",ir1);

	if(irF==0){
		irX = ir0;
		irF = 1;
	}
	else{
		irX = ir1;
		irF = 0;
	}

	

}//end of slpitIR


/*
void checkSetBits(){
	int i;

	for(i=0;i<sizeof(regListArr);i++){
		if(((regListBits>>i)&1) == '1'){		
			regListArr[i] = i;
		}
	}
}//end of checkSetBits
*/

/*
	isSigned
	Description: checks if op1 is a signed number
	sets the signed flag
*/

int isSigned(unsigned long op1){
	//printf("/n %X /n",op1>>7);
	//printf("/n op1 %04X: /n",op1);
	if(op1>>31) return 1;
	return 0;
}//end of isSigned

/*
	isZero
	Description: checks if op1 is zero
	sets the zero flag
*/

int isZero(unsigned long op1){
	if(op1 == 0) return 1;
	return 0;
}//end of isZero

/*
	isCarry() - determine if carry is generated by addition: op1+op2+C
	C can only have value of 1 or 0
*/

int isCarry(unsigned long op1, unsigned long op2, unsigned C){//rd,rn,c
	if((op2 == MAX32) && (C == 1)) return 1; //special case where op2 is at MAX32
	printf("\n**Calculating carryF: op1: %0X, op2: %0X, C: %d",op1,op2,C);
	printf("\n**Is op1: %X > %X",op1,(MAX32 - (op2) - C));
	return ((op1 > (MAX32 - (op2) - C))?1:0); 
}//end of isCarry

/*
	flags
	Description: sets the flags appropriately
	isSigned: checks if the result is signeds
	isZero: checks if result returns zero
	carryF: checks if the ALU returns a carry
*/

void flags(){
	signF = isSigned(ALU);
	zeroF = isZero(ALU);
	carryF = isCarry(reg[rd],reg[rn],carryF);//immeVal
}//end of flags

void dataProcessingIns(){
	int i=0;
	short opCode = (irX&dataProOpM)>>8;
	switch(opCode){
		case 0:
			printf("\nAND");
			ALU=reg[rd] & reg[rn];
			reg[rd]=ALU;
			//flags();
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 1:
			printf("\nEOR");
			ALU=reg[rd]^reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 2://SUB
			printf("\nNormal SUB");
			ALU=reg[rd]+(~reg[rn])+1;
			reg[rd] = ALU;
			flags();
			break;
		case 3://SXB
			printf("\nSIGN Extension **IS NOT IMPLEMENTED CORRECTLY**");
			ALU=(signed)reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 4://ADD
			printf("\nNormal ADD");
			ALU=reg[rd]+reg[rn];
			reg[rd]=ALU;
			flags();
			break;
		case 5://ADC
			printf("\nNormal Add with Carry");
			ALU=reg[rd]+reg[rn]+carryF;
			reg[rd]=ALU;
			flags();
			break;
		case 6://LSR
			printf("\nLSR");
			ALU=reg[rd] >> reg[rn]-1;
			signF = reg[rd]&1;
			ALU=reg[rd]>>1;
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 7://LSL				
			printf("\nLSL");
			//Shifts bits by reg[rn]-1 then masks the msb to set carry flag then shifts by 1 bit more
			ALU=reg[rd] << reg[rn]-1;
			signF = reg[rd]>>15;
			ALU = ALU << 1;
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 8://TST
			printf("\nTST");
			ALU = reg[rd] & reg[rn];
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 9://TEQ
			printf("\nTEQ");
			ALU = reg[rd]^reg[rn];
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 10://CMP
			printf("\nCMP");
			ALU = reg[rd]+(~reg[rn])+1;
			flags();
			break;
		case 11://ROR
			
			printf("\nROR");
			
			ALU = reg[rd];
			for(i=reg[rn];i<NUM_BITS_REG;i++){
				carryF = ALU&1;
				ALU = ALU >> 1;
				ALU = ALU|(carryF<<15);
			}
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 12://ORR
			printf("\nORR");
			ALU=reg[rd]|reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 13://MOV
			printf("\nMOV");
			ALU = reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 14://BIC
			printf("\nBIC");
			ALU=reg[rd]&(~reg[rn]);
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
		case 15://MVN
			printf("\nMVN");
			ALU=(~reg[rn]);
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;
	}//end of switch
}//end of dataProcessingIns

/*
	The offset is an 8-bit relative address. The 8-bit signed value is = to the PC.
*/

int conditionalBranch(){
	//irF=0;
	switch((irX&condBrM)>>8){
		case 0://EQ
			if(zeroF) return 1;
			break;
		case 1://NE
			if(!zeroF) return 1;
			break;
		case 2://CS
			if (carryF) return 1;
			break;
		case 3://CC
			if (!carryF) return 1;
			break;
		case 4://MI
			if (signF) return 1;
			break;
		case 5://PL
			if (!signF) return 1;
			break;
		case 6:
			break;
		case 7:
			break;
		case 8://HI
			if((carryF==1)&&(zeroF==0))
				return 1;
			break;
		case 9:
			if((carryF==0)||(zeroF==1))
				return 1;
			break;
		case 14://AL
			return 1;
			break;
	}//end of switch
	printf("\nCondition is not true");
	return 0;
}//end of conditionalBranch

void doConditionalBr(){
	char brVal = irX&lowerBitsM;
	printf("\n**Conditional Branch**");
	if(conditionalBranch()){
		irF=0;
		printf("\nCondition is true");
		printf("\nValue of PC: %X",PC);
		PC=PC+((signed long)brVal)-2;
		printf("\nValue of branch (signed): %X",(signed long)(brVal));
		printf("\nValue of branch (unsigned): %X",(irX&lowerBitsM));
		printf("\nBranching to loaction: %X",PC);
	}
}

void pushPullIns(){
	int i,j;
	printf("\n**Push or Pull Instruction**");

	maR = SP;
	//maR = maR&0x00003FFF;

	//printf("/n%X/n",maR);
	switch(LBit){
	case(0)://PSH
		printf("\nPush Instruction");
		switch(HBBit){
		case(0)://Low Reg
			for(i=0;i<8;i++){
				
				printf("\nPushing Low register(s)");
				if(((regListBits>>i)&1) == 1){	
					printf("\nPushing registers %d",i+8);
					//for(j=0;j<REG_SIZE;j++)
					//{
						maR = maR-4;
						maR = maR&memptrM;
						MEMORY[maR] = reg[i];
						//SP = --SP;
						//printf("/n%X/n",maR);
						//printf("/n%X/n",--SP);
					//}
				}
			}
			//printf("val of maR upon exit in low reg %X",maR);
			
			if(RBit == 1){
				printf("\nThere is an extra push");
				LR=PC;
				//for(j=0;j<REG_SIZE;j++)
					//	{
							maR = maR-4;
							maR = maR&memptrM;
							MEMORY[maR] = LR;
							//SP = --SP;
							printf("/nPushing %X/n",maR);
							//printf("/n%X/n",--SP);
						//}
			}
			else printf("\nNo extra push");
			break;
		case(1)://High Reg
			printf("\nPushing High Registers");
			for(i=0;i<8;i++){
				if(((regListBits>>i)&1) == 1){
					printf("\nPushing registers %d",i+8);
					//for(j=0;j<REG_SIZE;j++)
					//{
						maR = maR-4;
						maR = maR&memptrM;
						MEMORY[maR] = reg[(i+8)];
						//SP = --SP;
						//printf("/n%X/n",maR);
						//printf("/n%X/n",--SP);
				//	}
				}
			}
			//move this if statment before the break so it will be executed
			if(RBit == 1){
				printf("\nThere is an extra push");
				LR=PC;
				//for(j=0;j<REG_SIZE;j++)
				//		{
							maR = maR-4;
							maR = maR&memptrM;
							MEMORY[maR] = LR;
							//SP = --SP;
							printf("/n%X/n",maR);
							//printf("/n%X/n",--SP);
				//		}
			}
			else printf("\nNo extra push"); 
			break;
		}
		break;
	case(1)://PUL
		printf("\nPull Instruction");
		//printf("val of SP in pul %X",maR);
		if(RBit == 1){
			printf("\nThere is an extra Pull");
			//LR=SP;
			//for(j=0;j<REG_SIZE;j++)
			//		{
			maR = SP;
						mbR = MEMORY[maR];
						maR = maR+4;
						SP = maR;
						//mbR = MEMORY[maR++];
						//printf("mbr: %08X\n",mbR);
						//mbR = mbR<<8;
						
						//mbR += MEMORY[maR++];
						//printf("mbr: %08X\n",mbR);
						//mbR = mbR<<8;

						//mbR += MEMORY[maR++];
						//printf("mbr: %08X\n",mbR);
						//mbR = mbR<<8;

						//mbR += MEMORY[maR++];
						//printf("mbr: %08X\n",mbR);
						
						PC = mbR;//MEMORY[maR];//mbR;
						irF=0;
			///		}
		}
		else printf("\nNo extra pull");

		switch(HBBit){
			case(0)://Low Reg
				printf("\nPulling into Low Registers");
				maR = SP;
				for(i=0;i<8;i++){
					if(((regListBits>>i)&1) == 1){		

						
						mbR = MEMORY[maR];
						maR = maR+4;
						SP = maR;
						reg[i] = mbR;//MEMORY[maR];//mbR;

						irF=0;
						
					}
			}
			break;
			case(1)://High Reg
				printf("\nPulling High registers");
				maR = SP;
				for(i=0;i<8;i++){
					if(((regListBits>>i)&1) == 1){						
					//	for(j=0;j<REG_SIZE;j++)
					//		{
								mbR = MEMORY[maR];
								maR = maR+4;
								SP = maR;
								reg[(i+8)] = mbR;//MEMORY[maR];//mbR;
								irF=0;
					//		}
					}
				}
			break;
		}
		break;
	}//end of switch
	
	//printf("val of maR upon exit of push/pull func %X",maR);
	SP=maR;
	irF=0;
}//end of pushPullIns

void unconditionalBranch(){
	short linkbit = (irX&unconBrLiM)>>12;
	printf("\n**Unconditional Branch");
	switch(linkbit){
	case (0):
		printf(": without linker**");
		PC=(irX&lowerBitsM);
		irF=0;
		break;
	case (1):
		printf(": with linker**");
		LR=maR;		//this was LR=PC on 20150419 12:24
		PC=irX&unconBrOffsetM;
		irF=0;
		break;
	}//end of switch
}//end of unconditionalBranch

/*
	moveIns
	Description: move the immediate value from the insrtuction register to a register
*/

void movIns(){

	printf("\nImmediate Move");

	//printf(" iregH: %08X ",irX);
	ALU = immeVal;
	reg[rd] = ALU;
	//printf(" rd: %08X ",rd);
	//printf(" reg[%d]: %08X ",rd,reg[rd]);
	//flags();
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
}//end of movIns

/*
	addIns
	Description: add the immediate value to destination register
*/

void addIns(){
	printf("\nImmediate Add");
	printf("reg[%02X]: %08X",rd,reg[rd]);
	ALU	 = reg[rd] + immeVal;//reg[rn];
	printf("reg[rd]: %X",reg[rd]);
	//flags();
	carryF = isCarry(reg[rd],(immeVal),carryF);
	reg[rd] = ALU;
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
	
}//end of addIns

/*
	subIns
	Description: subtract the immediate value to destination register
*/

void subIns(){
	printf("\nImmediate Sub");
	
	ALU = reg[rd] + (~immeVal) + 1;	
	carryF = isCarry(reg[rd],(~immeVal),carryF);
	reg[rd] = ALU;
	
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
	
}//end of subIns

/*
	subIns
	Description: compares the immediate value to destination register
*/

void cmpIns(){
	printf("\nImmediate Comp INS");
	
	ALU = reg[rd]+(~immeVal)+1; 
	//reg[rd]  = ALU;
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
	carryF = isCarry(reg[rd],immeVal,carryF);
}//end of comIns


void loadStoreIns(){
	int i;
	printf("\n**Load/Store Instruction**");
	//printf("wrdByt: %X",wrdBytBit);
	switch(HBBit){//switch load a byte or a word
	case 0://store to memory
		printf("\nLoading/Storing Word\n");
		switch (LBit){//switch to do a load or a store
			case 1:
				
				printf("\nLoading Word from mem");
				/*
				maR = reg[rn];
				mbR = MEMORY[maR];
				printf("mbr: %X\n",mbR);
				mbR = mbR<<8;
				printf("mbr: %X\n",mbR);
				mbR += MEMORY[++maR];
				printf("mbr: %X\n",mbR);
				reg[rd] = mbR;//MEMORY[maR];//mbR;
				*/
				maR=reg[rn];
				printf("\nValue of maR after load: %X", maR);
				mbR = MEMORY[maR];
					//	maR = maR+8;//4
						//printf("\nValue of mbR after load: %X", mbR);
						//SP = maR;
						for(i=0;i<sizeofins;i++){
							mbR = (mbR << 8);
							mbR += ((unsigned char*)MEMORY)[maR++];
						}
				printf("\nValue of maR after load: %X", maR);
						
						reg[rd] = mbR;//MEMORY[maR];//mbR;
			break;

			case 0:
				printf("\nStoring Word to mem");
				maR = reg[rn];
				mbR = reg[rd];
				//MEMORY[maR]=mbR;//reg[rd];
				//mbR = mbR<<8;
				//MEMORY[++maR]=mbR;

		
				for(i=sizeofins-1;i>=0;i--){
					//MEMORY[maR]=mbR;
					printf("\nStoring: %X",(mbR>>8*i));
					MEMORY[maR++]=(mbR>>8*i);
					//mbR = (mbR >> 2);
					//mbR += ((unsigned char*)MEMORY)[maR++];
					
				}
				
			break;
		}//end of switch
		break;

	case 1://load from memory
		printf("\nLoad/Store byte");
		switch (LBit){
			case 1:
				printf("\nLoading Byte from memory");
				maR = reg[rn];
				mbR = MEMORY[maR];
				reg[rd] = mbR;//MEMORY[maR]&byteM;
			break;

			case 0:
				printf("\nStoring Byte to  memory");
				maR = reg[rn];
				mbR = reg[rd];
				MEMORY[maR]=mbR;//reg[rd]&byteM;
			break;
		}//end of switch
		break;
	}//end of switch

}//end of loadStoreIns

/*
	immediateIns
	Description: selects which immediate instuction to process based on the opCode returned
	0: immediate move instruction
	1: immediate compared instruction
	2: immediate add instruction
	3: immediate subtract instruction
*/

void immediateIns(){
	//printf(" PC2: %08X ",PC);
	//printf("\nSelecting Ins: %X \n",((irX >> 12) & opCodeM));
	switch((irX >> 12) & opCodeM){
	case 0:
		movIns();
		break;
	case 1:
		cmpIns();
		break;
	case 2:
		addIns();
		break;
	case 3:
		subIns();
		break;
	}//end of switch
}//end of immediateIns

/*
	stop
	Description: sets the stop flag
*/

void stop(){
	stopF = 1;
}

/*
	insType
	Description: returns the number corresponding to the instruction
	0: data processing
	1: load/store
	2&3: immediate instruction
	4: conditional branch
	5: push/pull
	6: unconditional branch
	7: stop
*/

void insType(){

	printf("\n**Determining ins type**");

	switch((irX >> 13)){
	/*
	case 0:
		return 0;
		break;
	case 1:
		return 1;
		break;
	case 2:
		return 2;//(irX >> 14);
		break;
	case 3:
		return 3;//(irX >> 14);
		break;
	case 4:
		return 4;
		break;
	case 5:
		return 5;
		break;
	case 6:
		return 6;
		break;
	case 7:
		return 7;
		break;
	}//end of switch

	*/
	//switch(insType()){
		case 0: dataProcessingIns();
			break;
		case 1: loadStoreIns();
			break;
		case 2:
		case 3:	immediateIns();
			break;
		//case 3: immediateIns();
		//	break;
		case 4: doConditionalBr();
			break;
		case 5: pushPullIns();
			break;
		case 6: unconditionalBranch();
			break;
		case 7: stop();
			break;
	}//end of switch

}



/*
	execute
	Description: processes the instruction type
	0: data processing instruction
	1: load/store instuction
	2&3: immediate instruction
	4: conditional branch
	5: push/pull *unimplemented
	6: unconditional branch
	7: stop
*/
void execute(){

	printf("\n**Executing**");
	
	printf("\nirR: %08X",irR);
	printf("\tirX: %04X ",irX);
	immeVal = (irX& immeM)>>4;	//determines the immediate value
	printf("\nimmeVal: %04X ",immeVal);
	rd = (irX & rdM);			//determines the register destination value 
	rn = (irX & rnM)>>4;		//determines the register source value
	printf("\nrd: %08d",rd);
	printf("\nrn: %08d",rn);
	regListBits = irX&lowerBitsM;	//masks out the lower 8 bits
	LBit = (irX & LBitM);
	
	LBit = LBit>>11;
	HBBit = (irX & HBBitM)>>10;
	RBit = (irX & RBitM)>>8;

	insType();
	//printf("RBit: %X\n",RBit);
	/*
	switch(insType()){
		case 0: dataProcessingIns();
			break;
		case 1: loadStoreIns();
			break;
		case 2:	immediateIns();
			break;
		case 3: immediateIns();
			break;
		case 4: conditionalBranch();
			break;
		case 5: pushPullIns();
			break;
		case 6: unconditionalBranch();
			break;
		case 7: stop();
			break;
	}//end of switch
	*/

}//end of execute

void insCycle(){
	printf("\nINS Cycle\n");
	//SP = MEMORY[STACK_BEG];
	
	if(irF==0){
		fetch(&MEMORY);	
		splitIR();					//splits the instruction registers
		execute();
		
			
	}
	else if(irF==1){
		//fetch(&MEMORY);
		splitIR();					//splits the instruction registers
		execute();
		
		
	}
	//printf(" instype: %X ",insType());

}
