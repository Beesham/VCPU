/*
* @Author Beesham Sarendranauth
* @Date: 2015/04/27
* @Description: contains all the instruction operations
*/

#include "MyLib.h"

unsigned short irX;		//holds the value of which register to use, ir0/ir1

unsigned short rd,rn;
unsigned long immeVal;
unsigned short LBit;
unsigned short HBBit;
unsigned short RBit;
unsigned long ALU;
unsigned short regListBits;
unsigned short regListArr[7] = {NULL};

/*
	splitIR()
	Description: determines which instruction register to use IR1/IR2
*/

void splitIR(){
	ir0 = (irR >> NUM_BITS_INS) & irM;
	ir1 = irR & irM;

	if(irF==0){
		irX = ir0;
		irF = 1;
	}
	else{
		irX = ir1;
		irF = 0;
	}
}//end of slpitIR


/*
	isSigned()
	Description: checks if op1 is a signed number
	returns the value to be set by the sign flag
*/

int isSigned(unsigned long op1){
	if(op1>>(NUM_BITS_REG-1)) return 1;
	return 0;
}//end of isSigned

/*
	isZero()
	Description: checks if op1 is zero
	returns the value to be set by the zero flag
*/

int isZero(unsigned long op1){
	if(op1 == 0) return 1;
	return 0;
}//end of isZero

/*
	isCarry() 
	Description: determine if carry is generated by addition: op1+op2+C
	C can only have value of 1 or 0
	returns the value to be set by the carry flag
*/

int isCarry(unsigned long op1, unsigned long op2, unsigned C){//rd,rn,c
	if((op2 == MAX32) && (C == 1)) return 1; //special case where op2 is at MAX32
	return ((op1 > (MAX32 - (op2) - C))?1:0); 
}//end of isCarry

/*
	flags()
	Description: sets the flags appropriately
	isSigned: checks if the result is signed and sets the flag
	isZero: checks if result returns zero and sets the flag
	isCarry: checks if the ALU returns a carry and sets the flag
*/

void flags(){
	signF = isSigned(ALU);
	zeroF = isZero(ALU);
	carryF = isCarry(reg[rd],reg[rn],carryF);//immeVal
}//end of flags

/*
	dataProcessingIns()
	Description: processes the opcode and its operation
				 sets flags with respect to operation
*/

void dataProcessingIns(){
	int i=0;
	char temp;
	short opCode = (irX&dataProOpM)>>8;
	switch(opCode){
		case 0://AND
			ALU=reg[rd] & reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 1://EOR
			ALU=reg[rd]^reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 2://SUB
			ALU=reg[rd]+(~reg[rn])+1;
			reg[rd] = ALU;
			flags();
			break;

		case 3://SXB
			temp = reg[rn];
			ALU=(signed long)temp;
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 4://ADD
			ALU=reg[rd]+reg[rn];
			flags();
			reg[rd]=ALU;
			break;

		case 5://ADC
			ALU=reg[rd]+reg[rn]+carryF;
			flags();
			reg[rd]=ALU;
			break;

		case 6://LSR
			ALU=reg[rd] >> reg[rn]-1;
			carryF = ALU&lsbM;
			ALU=reg[rd]>>1;
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 7://LSL				
			//Shifts bits by reg[rn]-1 then masks the msb to set carry flag then shifts by 1 bit more
			ALU=reg[rd] << reg[rn]-1;
			carryF = ALU>>NUM_BITS_REG-1;
			ALU = ALU << 1;
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 8://TST
			ALU = reg[rd] & reg[rn];
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 9://TEQ
			ALU = reg[rd]^reg[rn];
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 10://CMP
			ALU = reg[rd]+(~reg[rn])+1;
			flags();
			break;

		case 11://ROR
			ALU = reg[rd];
			for(i=0;i<reg[rn];i++){
				carryF = ALU&lsbM;
				ALU = ALU >> 1;
				ALU = ALU|(carryF<<(NUM_BITS_REG-1));
			}
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 12://ORR
			ALU=reg[rd]|reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 13://MOV
			ALU = reg[rn];
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 14://BIC
			ALU=reg[rd]&(~reg[rn]);
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

		case 15://MVN
			ALU=(~reg[rn]);
			reg[rd]=ALU;
			zeroF = isZero(ALU);
			signF = isSigned(ALU);
			break;

	}//end of switch
}//end of dataProcessingIns

/*
	conditionalBranch()
	Description: the offset is an 8-bit relative address. The 8-bit signed value is = to the PC.
	returns 1 if the conditions is true else 0
*/

int conditionalBranch(){
	switch((irX&condBrM)>>8){
		case 0://EQ
			if(zeroF) return 1;
			break;
		case 1://NE
			if(!zeroF) return 1;
			break;
		case 2://CS
			if (carryF) return 1;
			break;
		case 3://CC
			if (!carryF) return 1;
			break;
		case 4://MI
			if (signF) return 1;
			break;
		case 5://PL
			if (!signF) return 1;
			break;
		case 6:
			break;
		case 7:
			break;
		case 8://HI
			if((carryF==1)&&(zeroF==0))
				return 1;
			break;
		case 9:
			if((carryF==0)||(zeroF==1))
				return 1;
			break;
		case 14://AL
			return 1;
			break;
	}//end of switch
	return 0;
}//end of conditionalBranch


/*
	doConditionBr()
	Description: sets PC to the next instuction to be executed if successful branch

*/

void doConditionalBr(){
	char brVal = irX&lowerBitsM;
	if(conditionalBranch()){
		irF=0;
		PC=PC+((signed long)brVal)-2;
	}
}//end of doConditionalBr


/*
	pushPullIns()
	Description: push/pull operation
				 pushes low/high registers with/without linker
				 pulls  low/high registers with/without PC (PC=LR)
*/

void pushPullIns(){
	int i,j;

	maR = SP;
	switch(LBit){
	case(0)://PSH
		switch(HBBit){
		case(0)://Low Reg
			for(i=(NUM_OF_REGS/2);i>=0;i--){//loop to push registers highest to lowest		
				if(((regListBits>>i)&1) == 1){//shifts by i(the bit corresponding to the register), i will be the register to push				
					mbR = reg[i];
					for(j=0;j<sizeofins;j++){					
						--maR;
						maR = maR&memptrM;
						MEMORY[maR]=(mbR>>NUM_BITS_BYTE*j);//mem location = mbR shifted by 8*j(0-3)=8,16,24
					}					
				}
			}

			if(RBit == 1){//push LR
				LR=PC;
				mbR=LR;
				for(j=0;j<sizeofins;j++){					
					--maR;
					maR = maR&memptrM;
					MEMORY[maR]=(mbR>>NUM_BITS_BYTE*j);
				}
			}
			break;
		case(1)://High Reg
			for(i=(NUM_OF_REGS/2);i>=0;i--){
				if(((regListBits>>i)&1) == 1){
					mbR = reg[(i+(NUM_OF_REGS/2))];//add 8 because we are pushing the high registers, i+8: 0+8=8, 8+8=16
					for(j=0;j<sizeofins;j++){					
						--maR;
						maR = maR&memptrM;
						MEMORY[maR]=(mbR>>NUM_BITS_BYTE*j);
					}	
				}
			}

			if(RBit == 1){//push LR
				LR=PC;
				mbR=LR;
				for(j=0;j<sizeofins;j++){					
					--maR;
					maR = maR&memptrM;
					MEMORY[maR]=(mbR>>NUM_BITS_BYTE*j);
				}
			}
			break;
		}
		break;

	case(1)://PUL
		if(RBit == 1){//pull LR
			maR = SP;
			mbR = MEMORY[maR];
			for(j=0;j<sizeofins;j++){
				mbR = (mbR << NUM_BITS_BYTE);
				mbR += ((unsigned char*)MEMORY)[maR++];						
			}			
			SP = maR;						
			PC = mbR;
			irF=0;
		}

		switch(HBBit){
			case(0)://Low Reg
				maR = SP;
				for(i=0;i<(NUM_OF_REGS/2);i++){
					if(((regListBits>>i)&1) == 1){		
						mbR = MEMORY[maR];
						for(j=0;j<sizeofins;j++){
							mbR = (mbR << NUM_BITS_BYTE);
							mbR += ((unsigned char*)MEMORY)[maR++];						
						}				
						reg[i] = mbR;				
					}
			}
			break;
			case(1)://High Reg
				maR = SP;
				for(i=0;i<(NUM_OF_REGS/2);i++){
					if(((regListBits>>i)&1) == 1){						
						mbR = MEMORY[maR];
						for(j=0;j<sizeofins;j++){
							mbR = (mbR << NUM_BITS_BYTE);
							mbR += ((unsigned char*)MEMORY)[maR++];						
						}
						reg[(i+(NUM_OF_REGS/2))] = mbR;
					}
				}
			break;
		}
		break;
	}//end of switch
	SP=maR;
}//end of pushPullIns


/*
	unconditionalBranch()
	Description: offset is 12-bit absolute memory location
				 branches with/without linker
*/

void unconditionalBranch(){
	short linkbit = (irX&unconBrLiM)>>12;
	switch(linkbit){
	case (0)://no linker
		PC=(irX&lowerBitsM);
		irF=0;
		break;

	case (1)://with liker
		LR=PC;
		PC=irX&unconBrOffsetM;
		irF=0;
		break;
	}//end of switch
}//end of unconditionalBranch

/*
	moveIns()
	Description: move the immediate value from the instruction register to a register
*/

void movIns(){
	ALU = immeVal;
	reg[rd] = ALU;
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
}//end of movIns

/*
	addIns()
	Description: add the immediate value to destination register
*/

void addIns(){
	ALU	 = reg[rd] + immeVal;
	carryF = isCarry(reg[rd],(immeVal),carryF);
	reg[rd] = ALU;
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
}//end of addIns

/*
	subIns()
	Description: subtract the immediate value from destination register
*/

void subIns(){	
	ALU = reg[rd] + (~immeVal) + 1;	
	carryF = isCarry(reg[rd],(~immeVal),carryF);
	reg[rd] = ALU;	
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
}//end of subIns

/*
	cmpIns()
	Description: compares the immediate value to destination register
*/

void cmpIns(){	
	ALU = reg[rd]+(~immeVal)+1; 
	zeroF = isZero(ALU);
	signF = isSigned(ALU);
	carryF = isCarry(reg[rd],immeVal,carryF);
}//end of comIns


/*
	loadStoreIns()
	Description: rn - value is used as the moemory address in the register
				 rd - source/destination register
				 load/stores a double word from memory
				 load/stores a byte from memory
*/

void loadStoreIns(){
	int i;

	switch(HBBit){//switch load a byte or a word
	case 0://store to memory
		switch (LBit){//switch to do a load or a store
			case 1:				
				maR=reg[rn];
				mbR = MEMORY[maR];
				for(i=0;i<sizeofins;i++){
					mbR = (mbR << 8);
					mbR += ((unsigned char*)MEMORY)[maR++];
				}				
				reg[rd] = mbR;
			break;

			case 0:
				maR = reg[rn];
				mbR = reg[rd];
				for(i=sizeofins-1;i>=0;i--){
					MEMORY[maR++]=(mbR>>8*i);
				}		
			break;
		}//end of switch
		break;

	case 1://load from memory
		switch (LBit){
			case 1://loading byte
				maR = reg[rn];
				mbR = MEMORY[maR];
				reg[rd] = mbR&lowerByteM;//MEMORY[maR]&byteM;
			break;
			case 0://storing byte
				maR = reg[rd];
				mbR = reg[rn];
				MEMORY[maR]=mbR;//reg[rd]&byteM;
			break;
		}//end of switch
		break;
	}//end of switch
}//end of loadStoreIns

/*
	immediateIns()
	Description: selects which immediate instuction to process based on the opCode returned
	0: immediate move instruction
	1: immediate compared instruction
	2: immediate add instruction
	3: immediate subtract instruction
*/

void immediateIns(){
	switch((irX >> 12) & opCodeM){
	case 0:
		movIns();
		break;
	case 1:
		cmpIns();
		break;
	case 2:
		addIns();
		break;
	case 3:
		subIns();
		break;
	}//end of switch
}//end of immediateIns

/*
	stop()
	Description: sets the stop flag
*/

void stop(){
	stopF = 1;
}

/*
	insType()
	Description: returns the number corresponding to the instruction
	0: data processing
	1: load/store
	2&3: immediate instruction
	4: conditional branch
	5: push/pull
	6: unconditional branch
	7: stop
*/

void insType(){
	switch((irX >> 13)){//irX is shifted by 13 bits because we want the value of the top 2 bits of the register
		case 0: dataProcessingIns();
			break;
		case 1: loadStoreIns();
			break;
		case 2:
		case 3:	immediateIns();
			break;
		case 4: doConditionalBr();
			break;
		case 5: pushPullIns();
			break;
		case 6: unconditionalBranch();
			break;
		case 7: stop();
			break;
	}//end of switch
}//end of insType



/*
	execute()
	Description: processes the instruction type
	0: data processing instruction
	1: load/store instuction
	2&3: immediate instruction
	4: conditional branch
	5: push/pull 
	6: unconditional branch
	7: stop
*/
void execute(){
	immeVal = (irX& immeM)>>4;		//determines the immediate value
	rd = (irX & rdM);				//determines the register destination value 
	rn = (irX & rnM)>>4;			//determines the register source value
	regListBits = irX&lowerBitsM;	//masks out the lower 8 bits
	LBit = (irX & LBitM);	
	LBit = LBit>>11;
	HBBit = (irX & HBBitM)>>10;
	RBit = (irX & RBitM)>>8;

	insType();
}//end of execute

void insCycle(){
	if(irF==0){
		fetch(&MEMORY);	
		splitIR();					//splits the instruction registers
		execute();		
	}
	else if(irF==1){
		splitIR();					//splits the instruction registers
		execute();	
	}
}
